{"version":3,"file":"src-components-ExternalDocument-ExternalDocument-stories.59d01060.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmDA;;;;;;;;ACjCA;;;;;;;;;;ACmBA;;;ACpBA;;ACSA","sources":["webpack://@osuresearch/annotator/./src/components/ExternalDocument/NoteAnchor.tsx","webpack://@osuresearch/annotator/./src/components/ActionsSidebar/ActionsSidebar.tsx","webpack://@osuresearch/annotator/./src/components/Thread/EditableMessage.tsx","webpack://@osuresearch/annotator/./src/components/Thread/StartReply.tsx","webpack://@osuresearch/annotator/./src/components/AnchoredContainer/AnchoredContainer.tsx"],"sourcesContent":["import React, { SyntheticEvent, useEffect, useState } from 'react';\nimport { createPortal } from 'react-dom';\nimport styled from 'styled-components';\nimport { getHotkeyHandler } from '@mantine/hooks';\nimport { useFrame } from 'react-frame-component';\n\nimport { useThreads } from '../../hooks/useThreads';\nimport { useAnnotationFocus } from '../../hooks/useAnnotationFocus';\nimport { useElementPosition } from '../../hooks/useElementPosition';\nimport { useAnchorsContext } from '../../hooks/useAnchorsContext';\nimport { Anchor } from '../../types';\n\n// This is living as a styled component but will probably\n// be migrated to static CSS later in ExternalDocument.tsx.\n// I don't really care for the styled-components lock-in.\nconst NotesButton = styled.button`\n  border-radius: 3px;\n  background: white;\n  color: black;\n  border: 1px solid grey;\n  border-radius: 0;\n  padding: 4px;\n  margin: 4px;\n\n  z-index: 999;\n\n  // TODO: Deal with positioning. I can't guarantee a parent isn't\n  // a relative position or not. I'd *like* these to be document-absolute,\n  // but that means they can't be children of the target in the DOM.\n  position: absolute;\n  right: 0;\n  display: none;\n\n  &:hover {\n    background: grey;\n    cursor: pointer;\n  }\n\n  /* &[data-selected] {\n    background: yellow;\n  } */\n\n  &[data-focused] {\n    background: yellow;\n  }\n\n  &[data-threads] {\n    display: block;\n  }\n`;\n\nfunction NoteAnchorImpl({ anchor, el }: { anchor: Anchor; el: HTMLElement }) {\n  const { threads, isFocused, create, focusNext } = useThreads(anchor.source);\n\n  // Update the annotation actions widget when we focus this field\n  useAnnotationFocus(anchor.source, 'note', el);\n\n  // Except there's no concept of anchors here. Fuck I need a new name for that.\n\n  // Add hotkey support for the anchor\n  useEffect(() => {\n    const handler = getHotkeyHandler([\n      [\n        'mod+alt+M',\n        () => {\n          create('commenting', {\n            type: 'FragmentSelector',\n            value: '', // TODO: Copy value into here for context\n          });\n        }\n      ]\n\n      // TODO: Hotkey to focus first comment?\n    ]);\n\n    el.addEventListener('keydown', handler);\n    return () => el.removeEventListener('keydown', handler);\n  }, [el, create]);\n\n  const focusThreads = (e: SyntheticEvent<HTMLButtonElement>) => {\n    focusNext();\n    e.preventDefault();\n  };\n\n  return createPortal(\n    <NotesButton\n      onClick={focusThreads}\n      // data-selected={isAnnoFocused ? 'true' : undefined}\n      data-focused={isFocused ? 'true' : undefined}\n      data-threads={threads.length > 0 ? threads.length : undefined}\n    >\n      üìù {threads.length}\n    </NotesButton>,\n    el\n  );\n}\n\nexport function NoteAnchor(anchor: Anchor) {\n  const { document } = useFrame();\n  const [target, setTarget] = useState<HTMLElement>();\n  const { addAnchors } = useAnchorsContext();\n\n  const position = useElementPosition(target);\n\n  useEffect(() => {\n    console.log('update position', anchor, position);\n    addAnchors([\n      {\n        ...anchor,\n        target: position,\n      }\n    ]);\n  }, [anchor, position]);\n\n  // TODO: Remove anchors on unmount.\n\n  useEffect(() => {\n    setTarget(document?.getElementById(anchor.source) ?? undefined);\n  }, [anchor.source, document]);\n\n  if (!target) {\n    return null;\n  }\n\n  return <NoteAnchorImpl anchor={anchor} el={target} />;\n}\n","import React, { useEffect, useState } from 'react';\nimport { useAnnotationsContext } from '../../hooks/useAnnotationsContext';\nimport styled from 'styled-components';\nimport { AnnotationSelection, useAnnotationPicker } from '../../hooks/useAnnotationPicker';\nimport { useFocusWithin } from 'react-aria';\nimport { IconButton, Tooltip } from '@osuresearch/ui';\nimport { AnnotationMotivation } from '../../types';\n\nconst Panel = styled.div`\n  position: absolute;\n  right: 0;\n  transition: 200ms;\n  background: var(--rui-light);\n  border: 2px solid var(--rui-light-shade);\n  flex-direction: column;\n  margin-right: 4px;\n`;\n\nexport function ActionsSidebar() {\n  const { selected, select } = useAnnotationPicker();\n  const { createThread } = useAnnotationsContext();\n  const [isFocusWithin, onFocusWithinChange] = useState(false);\n  const { focusWithinProps } = useFocusWithin({\n    onFocusWithinChange\n  });\n\n  const [top, setTop] = useState(0);\n  const [prev, setPrev] = useState<AnnotationSelection>();\n  const [active, setActive] = useState<AnnotationSelection>();\n\n  const startThread = (motivation: AnnotationMotivation) => {\n    if (!active) {\n      return;\n    }\n\n    const thread = createThread('commenting', {\n      type: 'FragmentSelector',\n      value: active.targetField,\n\n      // If we have a text range selected, use that as refinement.\n      refinedBy: (active.start && active.end)\n        ? {\n            type: 'TextPositionSelector',\n            start: active.start,\n            end: active.end\n        }\n        : undefined\n    });\n  };\n\n  // TODO: All this useEffect stuff should be encapsulated elsewhere\n  // to a reusable tracker of what's selected and what isn't. It\n  // doesn't need to be in this component in particular.\n  useEffect(() => {\n    if (selected) {\n      setTop(selected.top);\n    }\n\n    if (selected) {\n      setPrev(selected);\n    }\n  }, [selected]);\n\n  useEffect(() => {\n    if (isFocusWithin) {\n      setActive(prev);\n    } else {\n      setActive(selected);\n    }\n  }, [isFocusWithin, prev, selected]);\n\n  return (\n    <Panel\n      style={{\n        top,\n        display: active ? 'flex' : 'none'\n      }}\n      {...focusWithinProps}\n    >\n      <Tooltip contentSlot=\"Ask a question\">\n        <IconButton\n          name=\"questioningComment\"\n          label=\"Ask a question\"\n          size={24}\n          onPress={() => startThread('questioning')}\n        />\n      </Tooltip>\n\n      <Tooltip contentSlot=\"Add a comment\">\n        <IconButton\n          name=\"addComment\"\n          label=\"Add a comment\"\n          size={24}\n          onPress={() => startThread('commenting')}\n        />\n      </Tooltip>\n\n      <Tooltip contentSlot=\"Make a suggestion\">\n        <IconButton name=\"suggestionComment\" label=\"Make a suggestion\" size={24} />\n      </Tooltip>\n      {/* <Button>\n        üí¨ {isFocusWithin ? 'focus' : 'nope'}\n        <br />\n        {selected ? selected.source : 'no sel'}\n        <br />\n        {prev ? 'prev: ' + prev.source : 'no prev'}\n        <br />\n        {active ? 'active: ' + active.source : 'no active'}\n      </Button> */}\n    </Panel>\n  );\n}\n","import React, { useEffect, useContext } from 'react';\nimport { Button, Group, Stack, Text } from '@osuresearch/ui';\nimport { useFocusWithin } from 'react-aria';\nimport { EditorContent, useEditor } from '@tiptap/react';\nimport Placeholder from '@tiptap/extension-placeholder';\nimport StarterKit from '@tiptap/starter-kit';\nimport { getHotkeyHandler } from '@mantine/hooks';\nimport styled from 'styled-components';\nimport { EditorsContext } from '../../hooks/useEditors';\n\nexport type EditableMessageProps = {\n  defaultValue: string;\n  placeholder?: string;\n  autosave?: boolean;\n  onSave: (value: string) => void;\n  onCancel: () => void;\n};\n\nconst EditorStyles = styled.div`\n\n  .ProseMirror {\n    border: 1px solid var(--rui-light);\n    padding: var(--rui-spacing-xs);\n  }\n  .ProseMirror-focused {\n    outline: none;\n    border: 1px solid var(--rui-light);\n  }\n`;\n\n/**\n * Rich text editor with a save/cancel button visible on mount.\n *\n * a11y\n * - Focuses on the text input on mount\n * - Traps keyboard focus until closed\n */\nexport function EditableMessage({\n  defaultValue,\n  placeholder,\n  autosave = false,\n  onSave,\n  onCancel\n}: EditableMessageProps) {\n  const { setActiveEditor } = useContext(EditorsContext);\n\n  const { focusWithinProps } = useFocusWithin({\n    onBlurWithin: (e) => {\n      // if (autosave) {\n      //   handleSave();\n      // } else {\n      //   handleCancel();\n      // }\n    }\n  });\n\n  const editor = useEditor(\n    {\n      content: defaultValue,\n      extensions: [\n        StarterKit,\n        Placeholder.configure({\n          placeholder\n        })\n      ]\n    },\n    []\n  );\n\n  const handleSave = () => {\n    if (!editor) {\n      return;\n    }\n\n    const textContent = editor.getText();\n    const content = editor.getHTML();\n\n    editor.chain().clearContent().blur().run();\n\n    setActiveEditor(false);\n    if (textContent.length > 0) {\n      onSave(content);\n    }\n    else {\n      onCancel();\n    }\n  };\n\n  const handleCancel = () => {\n    if (!editor) {\n      return;\n    }\n\n    editor.chain().clearContent().blur().run();\n\n    setActiveEditor(false);\n    onCancel();\n  };\n\n  useEffect(() => {\n    if (editor) {\n      editor.commands.focus('end');\n    }\n\n    setActiveEditor(true);\n\n    return () => setActiveEditor(false);\n  }, [editor]);\n\n  return (\n    <Stack align=\"stretch\" fs=\"sm\">\n      <EditorStyles>\n        <EditorContent\n          editor={editor}\n          onKeyDown={getHotkeyHandler([['mod+Enter', handleSave]])}\n        />\n      </EditorStyles>\n\n      <Group justify=\"end\" align=\"center\">\n        <Text fs=\"xs\" c=\"dark\">Tip: Press Ctrl+Enter to save.</Text>\n        <Button variant=\"subtle\" onPress={handleCancel}>Cancel</Button>\n        <Button onPress={handleSave}>Save</Button>\n      </Group>\n    </Stack>\n  );\n}\n","import React, { useState, useContext } from 'react';\nimport { Group, Stack, UnstyledButton } from '@osuresearch/ui';\nimport styled from 'styled-components';\nimport { useThread } from '../../hooks/useThread';\nimport { EditorsContext } from '../../hooks/useEditors';\nimport { EditableMessage } from './EditableMessage';\nimport { Annotation } from '../../types';\n\nexport type StartReplyProps = {\n  thread: Annotation;\n};\n\nconst Root = styled.div`\n  border: 1px solid var(--rui-light);\n  padding: var(--rui-spacing-xs);\n`;\n\nexport function StartReply({ thread }: StartReplyProps) {\n  const { hasActiveEditor } = useContext(EditorsContext);\n  const [active, setActive] = useState(false);\n  const { addReply } = useThread(thread.id);\n\n  const onSave = (message: string) => {\n    addReply(message);\n    setActive(false);\n  };\n\n  const onCancel = () => {\n    setActive(false);\n  }\n\n  const onReply = () => {\n    setActive(true);\n  }\n\n  return (\n    <Stack align=\"stretch\" fs=\"sm\">\n      {!active && (\n        <UnstyledButton isDisabled={hasActiveEditor} as={Root} onPress={onReply} c=\"dark\">\n          <Group>\n            {hasActiveEditor\n              ? 'Another comment is in progress.'\n              : 'Reply'\n            }</Group>\n        </UnstyledButton>\n      )}\n\n      {active && (\n        <EditableMessage\n          placeholder=\"Reply\"\n          onSave={onSave}\n          onCancel={onCancel}\n          defaultValue=\"\"\n        />\n      )}\n    </Stack>\n  );\n}\n","import React, { useEffect } from \"react\";\nimport styled from \"styled-components\";\nimport { IconButton } from \"@osuresearch/ui\";\nimport { useCellListItem } from \"../../hooks/useCellListItem\";\nimport { Anchor } from '../../types';\nimport { useElementSize } from \"../../hooks/useElementSize\";\n\nexport type AnchoredContainerProps = {\n  id: string\n  anchor?: Anchor\n  focused: boolean\n  children: React.ReactNode\n\n  /**\n   * Additional spacing between adjacent containers\n   */\n  gap: number;\n}\n\nconst AnimatedContainer = styled.div`\n  transition: 200ms;\n`;\n\n/**\n * Responsible for keeping body content aligned with a target anchor.\n */\nexport function AnchoredContainer({ id, anchor, focused, gap, children }: AnchoredContainerProps) {\n  const anchorPos = anchor?.target || { y: 0, x: 0, width: 0, height: 0 };\n\n  const { ref, height } = useElementSize();\n  const heightWithGap = height + gap;\n\n  const { item, update, focus } = useCellListItem(id, anchorPos.y);\n\n  useEffect(() => {\n    if (!item) {\n      return;\n    }\n\n    const updated = {...item};\n\n    if (heightWithGap !== item.height) {\n      updated.height = heightWithGap;\n      update(updated);\n    }\n\n    if (focused) {\n      focus();\n    }\n  }, [item, id, anchorPos, heightWithGap, focused]);\n\n  return (\n    <>\n    <IconButton size={20} label=\"Icon here\" name=\"comment\" style={{\n      position: 'absolute',\n      transform: `translateY(${item?.anchorCell ?? 0}px) translateX(-48px)`\n    }} />\n\n    <AnimatedContainer ref={ref} style={{\n      position: 'absolute',\n      transform: item?.cell\n        ? `translateY(${item?.cell ?? 0}px) translateX(${focused ? -12 :0}px)`\n        : undefined,\n    }}>\n      {children}\n    </AnimatedContainer>\n    </>\n  );\n}\n"],"names":[],"sourceRoot":""}