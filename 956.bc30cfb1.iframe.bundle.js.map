{"version":3,"file":"956.bc30cfb1.iframe.bundle.js","mappings":";;;;;;;;;;AAqCA;;;ACpBA;;ACOA","sources":["webpack://@osuresearch/annotator/./src/components/Thread/EditableMessage.tsx","webpack://@osuresearch/annotator/./src/components/Thread/StartReply.tsx","webpack://@osuresearch/annotator/./src/components/AnchoredContainer/AnchoredContainer.tsx"],"sourcesContent":["import React, { useEffect, useContext } from 'react';\nimport { Button, Group, Stack, Text } from '@osuresearch/ui';\nimport { FocusScope, useFocusWithin } from 'react-aria';\nimport { EditorContent, useEditor } from '@tiptap/react';\nimport Placeholder from '@tiptap/extension-placeholder';\nimport StarterKit from '@tiptap/starter-kit';\nimport { getHotkeyHandler } from '@mantine/hooks';\nimport styled from 'styled-components';\nimport { Context as EditorsContext } from '../../hooks/useEditors';\n\nexport type EditableMessageProps = {\n  defaultValue: string;\n  placeholder?: string;\n  autosave?: boolean;\n  onSave: (value: string) => void;\n  onCancel: () => void;\n};\n\nconst EditorWrapper = styled.div`\n\n  .ProseMirror {\n    border: 1px solid var(--rui-light);\n    padding: var(--rui-spacing-xs);\n  }\n  .ProseMirror-focused {\n    outline: none;\n    border: 1px solid var(--rui-light);\n  }\n`;\n\n/**\n * Rich text editor with a save/cancel button visible on mount.\n *\n * a11y\n * - Focuses on the text input on mount\n * - Traps keyboard focus until closed\n */\nexport function EditableMessage({\n  defaultValue,\n  placeholder,\n  autosave = false,\n  onSave,\n  onCancel\n}: EditableMessageProps) {\n  const { setActiveEditor } = useContext(EditorsContext);\n\n  const { focusWithinProps } = useFocusWithin({\n    onBlurWithin: (e) => {\n      // if (autosave) {\n      //   handleSave();\n      // } else {\n      //   handleCancel();\n      // }\n    }\n  });\n\n  const editor = useEditor(\n    {\n      content: defaultValue,\n      extensions: [\n        StarterKit,\n        Placeholder.configure({\n          placeholder\n        })\n      ]\n    },\n    []\n  );\n\n  const handleSave = () => {\n    if (!editor) {\n      return;\n    }\n\n    const textContent = editor.getText();\n    const content = editor.getHTML();\n\n    editor.chain().clearContent().blur().run();\n\n    setActiveEditor(false);\n    if (textContent.length > 0) {\n      onSave(content);\n    }\n    else {\n      onCancel();\n    }\n  };\n\n  const handleCancel = () => {\n    if (!editor) {\n      return;\n    }\n\n    editor.chain().clearContent().blur().run();\n\n    setActiveEditor(false);\n    onCancel();\n  };\n\n  useEffect(() => {\n    if (editor) {\n      editor.commands.focus('end');\n    }\n\n    setActiveEditor(true);\n  }, [editor]);\n\n  return (\n    // <FocusScope contain restoreFocus autoFocus>\n    <Stack align=\"stretch\" fs=\"sm\">\n      <EditorWrapper>\n        <EditorContent\n          editor={editor}\n          onKeyDown={getHotkeyHandler([['mod+Enter', handleSave]])}\n        />\n      </EditorWrapper>\n\n      <Group justify=\"end\" align=\"center\">\n        <Text fs=\"xs\" c=\"dark\">Tip: Press Ctrl+Enter to save.</Text>\n        <Button variant=\"subtle\" onPress={handleCancel}>Cancel</Button>\n        <Button onPress={handleSave}>Save</Button>\n      </Group>\n    </Stack>\n    // </FocusScope>\n  );\n}\n","import React, { useState, useContext } from 'react';\nimport { Group, Stack, UnstyledButton } from '@osuresearch/ui';\nimport { EditableMessage } from './EditableMessage';\nimport { useThread } from '../../hooks/useThread';\nimport { useAnnotationsContext } from '../../hooks/useAnnotationsContext';\nimport styled from 'styled-components';\nimport { Context as EditorsContext } from '../../hooks/useEditors';\n\nexport type StartReplyProps = {\n  thread: Annotation;\n};\n\nconst Root = styled.div`\n  border: 1px solid var(--rui-light);\n  padding: var(--rui-spacing-xs);\n`;\n\nexport function StartReply({ thread }: StartReplyProps) {\n  const { hasActiveEditor } = useContext(EditorsContext);\n  const [active, setActive] = useState(false);\n  const { addReply } = useThread(thread.id);\n\n  const onSave = (message: string) => {\n    addReply(message);\n    setActive(false);\n  };\n\n  const onCancel = () => {\n    setActive(false);\n  }\n\n  const onReply = () => {\n    setActive(true);\n  }\n\n  return (\n    <Stack align=\"stretch\" fs=\"sm\">\n      {!active && (\n        <UnstyledButton isDisabled={hasActiveEditor} as={Root} onPress={onReply} c=\"dark\">\n          <Group>\n            {hasActiveEditor\n              ? 'Another comment is in progress.'\n              : 'Reply'\n            }</Group>\n        </UnstyledButton>\n      )}\n\n      {active && (\n        <EditableMessage\n          placeholder=\"Reply\"\n          onSave={onSave}\n          onCancel={onCancel}\n          defaultValue=\"\"\n        />\n      )}\n    </Stack>\n  );\n}\n","import React, { useContext, useEffect } from \"react\";\nimport { useElementSize } from \"../../hooks/useElementSize\";\nimport { Context as CellListContext } from '../../hooks/useCellList';\nimport styled from \"styled-components\";\n\nexport type AnchoredContainerProps = {\n  id: string\n  anchor?: Anchor\n  focused: boolean\n  children: React.ReactNode\n\n  /**\n   * Additional spacing between adjacent containers\n   */\n  gap: number;\n}\n\nconst AnimatedContainer = styled.div`\n  transition: 200ms;\n`;\n\n/**\n * Responsible for keeping body content aligned with a target anchor.\n */\nexport function AnchoredContainer({ id, anchor, focused, gap, children }: AnchoredContainerProps) {\n  const { getItem, addItem, removeItem, updateItem, focus } = useContext(CellListContext);\n  const anchorPos = anchor?.target || { y: 0, x: 0, width: 0, height: 0 };\n\n  const item = getItem(id);\n\n  const { ref, height } = useElementSize();\n  const heightWithGap = height + gap;\n\n  // Sync mount of this component with a cell list entry.\n  // Only execute once we have an anchor position.\n  // And whenever the anchor moves, this should re-mount the\n  useEffect(() => {\n    if (anchorPos.y === 0) {\n      return;\n    }\n\n    addItem({ id, anchorCell: anchorPos.y, cell: anchorPos.y, height: heightWithGap });\n\n    return () => removeItem(id);\n    // TODO: anchorPos causes re-renders and a crash due to duplicate addItem() calls.\n  }, [id, anchorPos.y]);\n\n  useEffect(() => {\n    // Add an item to the cell list if we just mounted\n    const item = getItem(id);\n    if (item) {\n      const updated = {...item};\n\n      let changed = false;\n      // if (anchorPos.y !== item.anchorCell) {\n      //   console.log('set anchor', id);\n      //   updated.anchorCell = anchorPos.y;\n      //   changed = true;\n      // }\n\n      // // Lock the container to the anchor cell when focused\n      // if (focused && item.anchorCell !== item.cell) {\n      //   console.log('focus and lock', id);\n      //   updated.cell = item.anchorCell;\n      //   changed = true;\n      // }\n\n      if (heightWithGap !== item.height) {\n        console.log('change height', id);\n        updated.height = heightWithGap;\n        changed = true;\n      }\n\n      // // if (item.anchorCell === item.cell) {\n      // //   console.log('match anchor', id);\n      // //   updated.cell = updated.anchorCell;\n      // //   changed = true;\n      // // }\n\n      if (changed) {\n        updateItem(id, updated);\n      }\n\n      if (focused) {\n        focus(id);\n      }\n    }\n  }, [id, anchorPos, heightWithGap, focused]);\n\n  // This whole component can be encapsulated into a hook.\n\n  // TODO: Container MUST always be rendering (no early out)\n  // but also it needs to translateY correctly on mount rather\n  // than jumping to match cell.\n  // Or fade it in.. idk.\n\n  return (\n    <AnimatedContainer ref={ref} style={{\n      position: 'absolute',\n      transform: item?.cell\n        ? `translateY(${item?.cell ?? 0}px) translateX(${focused ? -20 :0}px)`\n        : undefined,\n    }}>\n      {/* {item?.id} - {item?.anchorCell ?? 'no anchor'} - {item?.cell ?? 'no cell'}\n      <br/>\n      {JSON.stringify(anchor?.target)} */}\n      {/* <br/>\n      height: {height} */}\n      {children}\n    </AnimatedContainer>\n  );\n}\n"],"names":[],"sourceRoot":""}