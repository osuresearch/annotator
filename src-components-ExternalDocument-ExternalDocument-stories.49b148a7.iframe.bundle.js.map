{"version":3,"file":"src-components-ExternalDocument-ExternalDocument-stories.49b148a7.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkDA;;;;;;;;ACjCA;;;AAKA;;;;;;;;;AC6BA;;;;;;;AAsBA","sources":["webpack://@osuresearch/annotator/./src/components/ExternalDocument/NoteAnchor.tsx","webpack://@osuresearch/annotator/./src/components/ActionsSidebar/ActionsSidebar.tsx","webpack://@osuresearch/annotator/./src/components/ExternalDocument/ExternalDocument.tsx"],"sourcesContent":["import React, { SyntheticEvent, useEffect, useState } from 'react';\nimport { createPortal } from 'react-dom';\nimport styled from 'styled-components';\nimport { getHotkeyHandler } from '@mantine/hooks';\nimport { useFrame } from 'react-frame-component';\n\nimport { useThreads } from '../../hooks/useThreads';\nimport { useAnnotationFocus } from '../../hooks/useAnnotationFocus';\nimport { useElementPosition } from '../../hooks/useElementPosition';\nimport { useAnchorsContext } from '../../hooks/useAnchorsContext';\n\n// This is living as a styled component but will probably\n// be migrated to static CSS later in ExternalDocument.tsx.\n// I don't really care for the styled-components lock-in.\nconst NotesButton = styled.button`\n  border-radius: 3px;\n  background: white;\n  color: black;\n  border: 1px solid grey;\n  border-radius: 0;\n  padding: 4px;\n  margin: 4px;\n\n  z-index: 999;\n\n  // TODO: Deal with positioning. I can't guarantee a parent isn't\n  // a relative position or not. I'd *like* these to be document-absolute,\n  // but that means they can't be children of the target in the DOM.\n  position: absolute;\n  right: 0;\n  display: none;\n\n  &:hover {\n    background: grey;\n    cursor: pointer;\n  }\n\n  /* &[data-selected] {\n    background: yellow;\n  } */\n\n  &[data-focused] {\n    background: yellow;\n  }\n\n  &[data-threads] {\n    display: block;\n  }\n`;\n\nfunction NoteAnchorImpl({ anchor, el }: { anchor: Anchor; el: HTMLElement }) {\n  const { threads, isFocused, create, focusNext } = useThreads(anchor.source);\n\n  // Update the annotation actions widget when we focus this field\n  useAnnotationFocus(anchor.source, 'note', el);\n\n  // Except there's no concept of anchors here. Fuck I need a new name for that.\n\n  // Add hotkey support for the anchor\n  useEffect(() => {\n    const handler = getHotkeyHandler([\n      [\n        'mod+alt+M',\n        () => {\n          create('commenting', {\n            type: 'FragmentSelector',\n            value: '', // TODO: Copy value into here for context\n          });\n        }\n      ]\n\n      // TODO: Hotkey to focus first comment?\n    ]);\n\n    el.addEventListener('keydown', handler);\n    return () => el.removeEventListener('keydown', handler);\n  }, [el, create]);\n\n  const focusThreads = (e: SyntheticEvent<HTMLButtonElement>) => {\n    focusNext();\n    e.preventDefault();\n  };\n\n  return createPortal(\n    <NotesButton\n      onClick={focusThreads}\n      // data-selected={isAnnoFocused ? 'true' : undefined}\n      data-focused={isFocused ? 'true' : undefined}\n      data-threads={threads.length > 0 ? threads.length : undefined}\n    >\n      üìù {threads.length}\n    </NotesButton>,\n    el\n  );\n}\n\nexport function NoteAnchor(anchor: Anchor) {\n  const { document } = useFrame();\n  const [target, setTarget] = useState<HTMLElement>();\n  const { addAnchors } = useAnchorsContext();\n\n  const position = useElementPosition(target);\n\n  useEffect(() => {\n    console.log('update position', anchor, position);\n    addAnchors([\n      {\n        ...anchor,\n        target: position,\n      }\n    ]);\n  }, [anchor, position]);\n\n  // TODO: Remove anchors on unmount.\n\n  useEffect(() => {\n    setTarget(document?.getElementById(anchor.source) ?? undefined);\n  }, [anchor.source, document]);\n\n  if (!target) {\n    return null;\n  }\n\n  return <NoteAnchorImpl anchor={anchor} el={target} />;\n}\n","import React, { useEffect, useRef, useState } from 'react';\nimport { useAnnotationsContext } from '../../hooks/useAnnotationsContext';\nimport styled from 'styled-components';\nimport { AnnotationSelection, useAnnotationPicker } from '../../hooks/useAnnotationPicker';\nimport { useFocusWithin } from 'react-aria';\nimport { IconButton, Tooltip } from '@osuresearch/ui';\n\nconst Panel = styled.div`\n  position: absolute;\n  right: 0;\n  transition: 200ms;\n  background: var(--rui-light);\n  border: 2px solid var(--rui-light-shade);\n  flex-direction: column;\n  margin-right: 4px;\n`;\n\nconst Button = styled.button`\n  background: none;\n  border: 0;\n`;\n\nexport function ActionsSidebar() {\n  const { selected, select } = useAnnotationPicker();\n  const { createThread } = useAnnotationsContext();\n  const [isFocusWithin, onFocusWithinChange] = useState(false);\n  const { focusWithinProps } = useFocusWithin({\n    onFocusWithinChange\n  });\n\n  const [top, setTop] = useState(0);\n  const [prev, setPrev] = useState<AnnotationSelection>();\n  const [active, setActive] = useState<AnnotationSelection>();\n\n  const startThread = (motivation: AnnotationMotivation) => {\n    if (!active) {\n      return;\n    }\n\n    const thread = createThread('commenting', {\n      type: 'FragmentSelector',\n      value: active.targetField,\n\n      // If we have a text range selected, use that as refinement.\n      refinedBy: (active.start && active.end)\n        ? {\n            type: 'TextPositionSelector',\n            start: active.start,\n            end: active.end\n        }\n        : undefined\n    });\n  };\n\n  // TODO: All this useEffect stuff should be encapsulated elsewhere\n  // to a reusable tracker of what's selected and what isn't. It\n  // doesn't need to be in this component in particular.\n  useEffect(() => {\n    if (selected) {\n      setTop(selected.top);\n    }\n\n    if (selected) {\n      setPrev(selected);\n    }\n  }, [selected]);\n\n  useEffect(() => {\n    if (isFocusWithin) {\n      setActive(prev);\n    } else {\n      setActive(selected);\n    }\n  }, [isFocusWithin, prev, selected]);\n\n  return (\n    <Panel\n      style={{\n        top,\n        display: active ? 'flex' : 'none'\n      }}\n      {...focusWithinProps}\n    >\n      <Tooltip contentSlot=\"Ask a question\">\n        <IconButton\n          name=\"question\"\n          label=\"Ask a question\"\n          size={24}\n          onPress={() => startThread('questioning')}\n        />\n      </Tooltip>\n\n      <Tooltip contentSlot=\"Add a comment\">\n        <IconButton\n          name={active?.type === 'note' ? \"image\" : 'edit'}\n          label=\"Add a comment\"\n          size={24}\n          onPress={() => startThread('commenting')}\n        />\n      </Tooltip>\n\n      <Tooltip contentSlot=\"Make a suggestion\">\n        <IconButton name=\"edit\" label=\"Make a suggestion\" size={24} />\n      </Tooltip>\n      {/* <Button>\n        üí¨ {isFocusWithin ? 'focus' : 'nope'}\n        <br />\n        {selected ? selected.source : 'no sel'}\n        <br />\n        {prev ? 'prev: ' + prev.source : 'no prev'}\n        <br />\n        {active ? 'active: ' + active.source : 'no active'}\n      </Button> */}\n    </Panel>\n  );\n}\n","import React, { useLayoutEffect, useImperativeHandle, useRef, useState } from 'react';\nimport { Code, Group, Heading, Paper, Stack } from '@osuresearch/ui';\nimport Frame from 'react-frame-component';\nimport styled from 'styled-components';\n\nimport { Controller } from './Controller';\nimport { TableOfContents } from '../TableOfContents/TableOfContents';\nimport { ActionsSidebar } from '../ActionsSidebar';\n\nimport { useAnchors, Context } from '../../hooks/useAnchors';\nimport { ThreadList } from '../ThreadList';\n\n// Styles to inject into the inner iframe\n// TODO: I hate this. Better solution?\n// I don't want to lock consumers into styled-components or similar.\nconst STYLES = `\n  comment-view[data-comment] {\n    background-color: yellow;\n  }\n\n  comment-focus-view[data-comment] {\n    background-color: gold;\n    text-decoration: underline;\n  }\n\n  [data-comment-block]:hover {\n    cursor: pointer;\n    background-color: lightyellow;\n  }\n`;\n\nexport type ExternalDocumentProps = {\n  /**\n   * DOM content to render as a reviewable document.\n   *\n   * This cannot be changed once the component has mounted.\n   */\n  content: string;\n};\n\nconst PageLayout = styled.div`\n  // A4 page size\n  /* min-width: 21cm; */\n  /* height: 29.7cm;\n  margin: 30mm 45mm 30mm 45mm; */\n  display: flex;\n  flex-direction: row;\n\n  border: 1px solid red;\n`;\n\nconst A4Page = styled.div`\n  border: 1px solid green;\n  background: #fff;\n\n  min-width: 21cm;\n  width: 21cm;\n  padding: 64px;\n`;\n\n/**\n * Container for a reviewable document that was generated through\n * an external HTML renderer.\n *\n * Document content is rendered within a controlled iframe\n * and tagged elements are converted into controlled React\n * components through a portal.\n *\n * ## üìñ Storybook Dev Mode\n *\n * Note that running this in Storybook dev mode may occasionally break\n * due to hot reloading. The component is built to be mounted once.\n */\nexport function ExternalDocument(props: ExternalDocumentProps) {\n  const frameRef = useRef<HTMLIFrameElement>(null);\n  const listRef = useRef<HTMLDivElement>(null);\n\n  // Sync scroll positions between the frame and annotations aside.\n  // TODO: This isn't particularly performant (or smart) but I don't\n  // want the annotations inside the frame without a scoped CSS reset.\n  // Any other ideas?\n  useLayoutEffect(() => {\n    if (!frameRef.current) {\n      return;\n    }\n\n    // Since we control iframe content, we don't need a complex\n    // postmessage/receive message solution. Can just monitor iframe height directly.\n    // It is a bit too frequent since I'm using animation frames, but\n    // it may not be an actual problem. Will need to benchmark.\n\n    // Alternatively, useElementSize() may be sufficient if it works with iframes.\n\n    let handle: number;\n    let prev = 0;\n\n    const watch = () => {\n      const container = frameRef.current?.contentWindow?.document.body;\n\n      cancelAnimationFrame(handle);\n\n      if (container && prev !== container.scrollHeight) {\n        prev = container.scrollHeight;\n\n        // Some additional padding is added for... reasons.\n        frameRef.current.height = prev + 64 + 'px';\n      }\n\n      handle = requestAnimationFrame(watch);\n    };\n\n    handle = requestAnimationFrame(watch);\n    return () => cancelAnimationFrame(handle);\n  }, [frameRef, listRef]);\n\n  const ctx = useAnchors();\n  const document = frameRef.current?.contentWindow?.document;\n\n  return (\n    <Context.Provider value={ctx}>\n      <Group bgc=\"light\" justify=\"center\" miw=\"calc(21cm + 400px)\" py=\"md\" align=\"stretch\" gap={0}>\n        {document && <TableOfContents  document={document} />}\n        <Paper w=\"21cm\" miw=\"21cm\" p=\"xxl\" withBorder shadow=\"md\">\n          <Frame\n            ref={frameRef}\n            initialContent={props.content}\n            head={<style>{STYLES}</style>}\n            onLoad={(e) => e.stopPropagation()}\n            style={{\n              width: '100%',\n              margin: 0\n            }}\n          >\n            <Controller />\n          </Frame>\n\n          <ActionsSidebar />\n        </Paper>\n        <Stack align=\"stretch\" w={400} miw={400} pt=\"xxl\" className=\"threads\">\n          <ThreadList ref={listRef} />\n        </Stack>\n      </Group>\n    </Context.Provider>\n  );\n}\n"],"names":[],"sourceRoot":""}