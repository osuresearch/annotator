{"version":3,"file":"479.350f0ebb.iframe.bundle.js","mappings":";;;;;;;;AAaA;;;;;AAoEA","sources":["webpack://@osuresearch/annotator/./src/components/Thread/AnchoredContainer.tsx"],"sourcesContent":["import React, { useContext, useEffect, useLayoutEffect, useRef, useState } from \"react\";\nimport { getDocumentPosition } from \"../../utils\";\nimport { useAnchorsContext } from \"../../hooks/useAnchorsContext\";\nimport { CellListItem, Context as CellListContext } from '../../hooks/useCellList';\nimport styles from 'styled-components';\n\nexport type AnchoredContainerProps = {\n  id: string\n  el?: HTMLElement\n  focused: boolean\n  children: React.ReactNode\n}\n\nconst AlignmentMark = styles.div`\n  position: absolute;\n  width: 100vw;\n  top: 0;\n  left: 0;\n  margin-left: -30em;\n  border-top: 1px solid black;\n  background-color: #eee;\n`;\n\nconst Container = styles.div`\n  position: absolute;\n  border: 1px solid red;\n  top: 0;\n  margin-top: -20px;\n`;\n\nfunction Debug({\n  id, el, focused\n}: {\n  id: string\n  el?: HTMLElement\n  focused: boolean\n}) {\n  const { items, getItem } = useContext(CellListContext);\n  const cellItem = getItem(id);\n\n  if (!el || !cellItem) {\n    return <div>No element</div>\n  }\n\n  const top = Math.round(getDocumentPosition(el).top);\n\n  return (\n    <div>\n      {JSON.stringify(cellItem, undefined, 2)}\n      <br/>\n      El: {el.id} @ {top}\n\n      <AlignmentMark style={{ borderColor: 'red', top: (cellItem.anchorCell - cellItem.cell)  }}>\n          {el.id} anchor cell offset\n      </AlignmentMark>\n\n      <AlignmentMark style={{ borderColor: 'green' }}>\n          {el.id} @ top: {top}\n          , anchorCell: {cellItem?.anchorCell}\n          , cell: {cellItem?.cell}\n      </AlignmentMark>\n\n\n\n      {/* <br />\n      {fieldAnchor ? fieldAnchor.id : ' no field anchor'}\n      <br />\n      {scopedAnchor ? scopedAnchor.id : ' no scoped anchor'}\n      <br />\n      <Text fw=\"bold\">{fieldAnchor?.target?.getBoundingClientRect().top}</Text>\n      <Code block>{JSON.stringify(items, undefined, 2)}</Code> */}\n    </div>\n  );\n}\n\n\n\n\n/**\n * Responsible for keeping body content aligned with a target anchor.\n */\nexport function AnchoredContainer({ id, el, focused, children }: AnchoredContainerProps) {\n  const ref = useRef<HTMLDivElement>(null);\n  const { items, getItem, addItem, removeItem, updateItem, focus } = useContext(CellListContext);\n  const [top, setTop] = useState(0);\n  const [height, setHeight] = useState(0);\n\n  // Add this container into the cell list on mount\n  useLayoutEffect(() => {\n    if (!el || !ref.current) {\n      return;\n    }\n\n    const anchorCell = Math.round(getDocumentPosition(el).top);\n    const height = ref.current.offsetHeight;\n\n    addItem({ id, anchorCell, cell: anchorCell, height });\n\n    setTop(anchorCell);\n    setHeight(height);\n\n    return () => {\n      removeItem(id);\n    };\n  }, [id, el, ref]);\n\n  const item = getItem(id);\n\n  useEffect(() => {\n    const item = getItem(id);\n    if (!item) {\n      return;\n    }\n\n    if (item.cell !== top) {\n      console.log('update top', el?.id, item.cell);\n      setTop(item.cell);\n    }\n\n    // If the item height doesn't match our own, update it.\n    if (item.height !== height) {\n      updateItem(id, { ...item, height });\n    }\n  }, [items, top, height, id]);\n\n  // Monitor for changes to the top position of our anchor\n  useEffect(() => {\n    // TODO: This is going to be REAL SLOW since this is\n    // constantly monitoring and reading DOM positions\n    // recursively up parents. Need a solution that works\n    // better. Unfortunately there's no ResizeObserver\n    // equivalent that isn't just frequent polling.\n    // May want to encapsulate this elsewhere\n\n    let prevTop = 0;\n\n    const handle = setInterval(() => {\n      if (!el) {\n        console.log('no el');\n        return;\n      }\n\n      const top = Math.round(getDocumentPosition(el).top);\n\n      if (top === prevTop) {\n        console.log('same top');\n        return;\n      }\n\n      const item = getItem(id);\n      if (!item || top === item.anchorCell) {\n        return;\n      }\n\n      console.log('Update top', el.id, prevTop, top, id);\n      prevTop = top;\n      updateItem(id, {\n        ...item,\n        anchorCell: top,\n      });\n    }, 1000);\n\n    return () => clearInterval(handle);\n  }, [id, item]);\n\n  // Observe container height changes and\n  // update our cell item to match\n  useEffect(() => {\n    if (!ref.current) {\n      return;\n    }\n\n    const container = ref.current;\n\n    const observer = new ResizeObserver(() => {\n      if (!ref.current || !item) {\n        return;\n      }\n\n      const newHeight = ref.current.offsetHeight;\n      if (newHeight === item.height) {\n        return;\n      }\n\n      setHeight(newHeight);\n    });\n\n    observer.observe(container);\n\n    return () => observer.unobserve(container);\n  }, [id, ref, item]);\n\n  // Lock our container to its anchor cell when focused\n  useEffect(() => {\n    if (focused) {\n      const item = getItem(id);\n      if (!item || item.cell === item.anchorCell) {\n        return;\n      }\n\n      // Jump it to the anchor point\n      updateItem(id, {\n        ...item,\n        cell: item.anchorCell,\n      });\n    }\n\n  }, [items, id, focused]);\n\n  return (\n    <Container ref={ref} style={{ top: top }}>\n      {children}\n      {/* <Debug id={id} el={el} focused={focused} /> */}\n    </Container>\n  );\n}\n"],"names":[],"sourceRoot":""}